.\" -*- mode: nroff; coding: utf-8 -*-
.\" Copyright (c) 2023 Gwen Weinholt
.\" SPDX-License-Identifier: MIT
.TH define-record-type 7scm 2023-08-08 "" "Scheme Programmer's Manual"
.SH NAME
define-record-type \- define a record type
.
.SH LIBRARY
.nf
.BR "(import (rnrs))" "                     ;R6RS"
.BR "(import (rnrs records syntactic))" "   ;R6RS"
.BR "(import (scheme base))" "              ;R7RS"
.
.SH SYNOPSIS
.nf
; R6RS
.BI "(define-record-type " name-spec " " record-clause " " \fR...\fP )
.BI "(record-type-descriptor " record-name )
.BI "(record-constructor-descriptor " record-name )

; R6RS name-spec
.BI "(" record-name " " constructor-name " " predicate-name )
.I record-name

; R6RS record-clause
; The symbols here are exported as auxiliary syntax.
.BI "(fields " field-spec " " \fR...\fP )
.BI "(sealed " boolean )
.BI "(parent " parent-name )
.BI "(parent-rtd " parent-rtd " " parent-rcd )
.BI "(protocol " expression )
.BI "(opaque " boolean )
.BI "(nongenerative " uid )
.BI "(nongenerative)"

; R6RS field-spec
.BI "(immutable " field-name " " accessor-name )
.BI "(mutable " field-name " " accessor-name " " mutator-name )
.BI "(immutable " field-name )
.BI "(mutable " field-name )
.I field-name

; R7RS
.BI "(define-record-type " record-name
.BI "  (" constructor-name " " field-name " " \fR...\fP )
.BI "  " predicate-name
.BI "  " field-spec " " \fR...\fP )

; R7RS field-spec
.BI ( field-name " " accessor-name )
.BI ( field-name " " accessor-name " " modifier-name )
.
.SH DESCRIPTION
Defines a record type along with associated constructor descriptor and
constructor, predicate, field accessors, and field mutators.
.
.TP
.B Record names
The
.I name-spec
specifies the names of the record type,
constructor, and predicate.
In the R6RS variant it can take the form
.
.BI "(" record-name " " constructor-name " " predicate-name )
or
.IR record-name .
In the R7RS variant it can only take the form
.I record-name
and the constructor and predicate are specified later.
.IP
The
.IR record-name ,
.IR constructor-name ,
and
.I predicate-name
must all be identifiers.
.
The
.IR record-name ,
taken as a symbol, becomes the name of the record type. See
.BR make-record-type-descriptor (3scm).
.IP
The
.I record-name
is bound to an expand-time or run-time representation of the record
type. In R6RS this binding can be used as parent name in syntactic
record-type definitions that extend this definition. It can also be
used as a handle to gain access to the underlying record-type
descriptor and constructor descriptor by using
.B record-type-descriptor
and
.BR record-constructor-descriptor .
.
.IP
The short form of
.I name-spec
specifies only
.I record-name
and
is an abbreviation for the
longer form, where the name of the constructor is generated
by prefixing the record name with \f[CR]make-\fP, and the predicate
name is generated by adding a question mark (\f[CR]?\fP) to the
end of the record name.
.IP
For example, if the record name is
\f[CR]frob\fP, the name of the constructor is
\f[CR]make-frob\fP, and the
predicate name is
\f[CR]frob?\fP.
.
.TP
.B [R6RS] The constructor
The constructor is bound to
.I constructor-name
and is a procedure that constructs instances of the defined record
type.
.
It uses a protocol specified by the
.B protocol
clause, or, in its absence, using a default protocol. For details on
protocols, see the description of the
.B protocol
clause below.
.IP
The way the constructor works depends on whether the type is a base
type or a subtype, and whether the there is an explicit
.B protocol
clause or if the default protocol is used instead. These four cases
are described below.
.
.TP
.B [R6RS] Constructor for a base type; default protocol
The constructor accepts as many
arguments as there are fields, in the same order as they
appear in the
.B fields
clause, and returns a record object with the fields initialized to the
corresponding arguments.
.
.
.TP
.B [R6RS] Constructor for a subtype; default protocol
.
The constructor accepts arguments corresponding to
the parent types' constructor first, and then one argument for each
field in the same order as in the
.B fields
clause, and returns a record object with the fields initialized to the
corresponding arguments.
.
.TP
.B [R6RS] Constructor for a base type; explicit protocol
The
.B protocol
expression, if it evaluates to a
value, must evaluate to a procedure, and this procedure
should accept a single argument. The protocol
procedure is called once during the evaluation of the
.B define-record-type
form with a procedure
.I p
as its
argument. It should return a procedure, which will
become the constructor bound to
.IR constructor-name .
.IP
The procedure
.I p
accepts as many arguments as there
are fields, in the same order as they appear in the
.B fields
clause, and returns a record object with the
fields initialized to the corresponding arguments.
.IP
The constructor returned by the protocol procedure
can accept an arbitrary number of arguments, and
should call
.I p
once to construct a record object, and
return that record object.
.IP
For example, the following protocol expression for a
record-type definition with three fields creates a
constructor that accepts values for all fields, and
initialized them in the reverse order of the arguments:
.IP
.EX
(lambda (p)
  (lambda (v1 v2 v3)
    (p v3 v2 v1)))
.EE
.
.TP
.B [R6RS] Constructor for a subtype; explicit protocol
The protocol procedure is called
once with a procedure
.I n
as its argument. As in the
previous case, the protocol procedure should return a
procedure, which will become the constructor bound
to
.IR constructor-name .
However,
.I n
is different from
.I p
in the previous case: It accepts arguments corresponding to the
arguments of the constructor of the parent type. It then returns a
procedure
.I p
that accepts as
many arguments as there are (additional) fields in this
type, in the same order as in the fields clause, and
returns a record object with the fields of the parent
record types initialized according to their constructors
and the arguments to
.IR n ,
and the fields of this record
type initialized to its arguments of
.IR p .
.IP
The constructor returned by the protocol procedure
can accept an arbitrary number of arguments, and
should call
.I n
once to construct the procedure
.IR p ,
and
call
.I p
once to create the record object, and finally
return that record object.
.IP
For example, the following protocol expression
assumes that the constructor of the parent type takes
three arguments:
.IP
.EX
(lambda (n)
  (lambda (v1 v2 v3 x1 x2 x3 x4)
    (let ((p (n v1 v2 v3)))
      (p x1 x2 x3 x4))))
.EE
.IP
The resulting constructor accepts seven arguments,
and initializes the fields of the parent types
according to the constructor of the parent type, with
.IR v1 ,
.IR v2 ,
and
.I v3
as arguments. It also initializes the fields of
this record type to the values of
.IR x1 ,
.IR x2 ,
.IR x3
and
.IR x4 .
.
.TP
.B [R6RS] Protocol restrictions and freedoms
.
If there is a
.B parent
clause, but no
.B protocol
clause,
then the parent type must not have a
.B protocol
clause
itself. Similarly, if there is a
.B parent-rtd
clause whose
.B parent-rtd
evaluates to a record-type descriptor, but
no
.B protocol
clause, then the
.B parent-rcd
expression,
if it evaluates to a value, must evaluate to \f[CR]#f\fP.
.IP
A protocol may perform other actions consistent with the requirements
described above, including mutation of the new record or other side
effects, before returning the record.
.
.IP
.
.
.TP
.B [R7RS] The constructor
The constructor is bound to
.I constructor-name
and it is a procedure that takes as many arguments as there are
.IR field-name s
in the
.BI "  (" constructor-name " " field-name " " \fR...\fP )
part of the definition and returns a new record of type
.IR record-name .
Fields whose names are
listed with
.I constructor-name
have the corresponding
argument as their initial value. The initial values of
all other fields are unspecified.
It is an error for a
.I field-name
to appear in constructor but not as a
.IR field-name .
.
.TP
.B The predicate
The
.I predicate-name
is defined by this definition to a predicate
for the defined record type.
It is bound to a procedure that returns \f[CR]#t\fP when
given a value returned by the procedure bound to
.I constructor-name
and \f[CR]#f\fP for everything else. The predicate also returns true
for values of subtypes of the record type.
.
.TP
.B [R7RS] Record, constructor and predicate names
.
These names are always specified explicitly in R7RS. There is no
way to get the names automatically generated as in R6RS.
.
.
.PP
Each
.I record-clause
must take one of the forms in the synopsis; it is a syntax violation
if multiple
.IR record-clause s
of the
same kind appear in a
.B define-record-type
form.
.
.
.TP
.B [R6RS] Field specifications
Each
.I field-spec
has one of the following forms:
.IP
.BI "(immutable " field-name " " accessor-name )
.br
.BI "(mutable " field-name " " accessor-name " " mutator-name )
.br
.BI "(immutable " field-name )
.br
.BI "(mutable " field-name )
.br
.I field-name
.IP
The
.IR field-name ,
.IR accessor-name ,
and
.I mutator-name
must all be identifiers.
.IP
All forms declare a field called
.IR field-name ,
which is either immutable or mutable.
.IP
The names of the accessor and mutator can optionally be specified
manually by supplying
.I accessor-name
and/or
.IR mutator-name .
Otherwise
the accessor
name is generated by appending the record name and field
name with a hyphen separator, and the mutator name (for
a mutable field) is generated by adding a \f[CR]-set!\fP
suffix to the accessor name.
.IP
For example, if the record name is \f[CR]frob\fP and the field name is
\f[CR]widget\fP, the accessor name is \f[CR]frob-widget\fP and the
mutator name is \f[CR]frob-widget-set!\fP.
.IP
If
.I field-spec
is just a
.I field-name
form, it is an abbreviation for \f[CR](immutable field-name)\fP.
.IP
The
.IR field-name s
become, as symbols, the names of the fields in the record-type
descriptor being created, in the same order.
.IP
The fields clause may be absent; this is equivalent to an
empty fields clause.
.
.
.TP
.B [R7RS] Field specifications
.
Each
.I accessor-name
is bound to a procedure that
takes a record of type
.I record-name
and returns the current value of the corresponding field. It is an
error to pass an accessor a value which is not a record of the
appropriate type.
.IP
Each
.I modifier-name
is bound to a procedure that
takes a record of type
.I record-name
and a value which becomes the new value of the corresponding field; an
unspecified value is returned. It is an error to pass a modifier a
first argument which is not a record of the appropriate type.
.IP
It is an error for the same identifier to occur more than once
as a field name. It is also an error for the same identifier
to occur more than once as an accessor or mutator name.
.
.
.TP
.B [R6RS] Sealed record types
The record clause
.BI "(sealed " \f[CR]#t\fP )
defines the record type as sealed, i.e., no extensions of the record
type can be created. A sealed record type cannot be used as a parent
record type.
.IP
The default, which can be explicitly declared with
.BI "(sealed " \f[CR]#f\fP )\fR,
is that the defined record type is not sealed.
.
.TP
.B [R6RS] Record single inheritance
The record clause
.BI "(parent " parent-name )
specifies that the record type is to have parent
type
.IR parent-name ,
where
.I parent-name
is the
.I record-name
of a record type previously defined using
.BR define-record-type.
.IP
The record-type definition
associated with
.I parent-name
must not be sealed.
.
.TP
.B [R6RS] Single inheritance via explicit rtd/rcd
The clause
.BI "(parent-rtd " parent-rtd " " parent-rcd )
specifies that the record type is to have its parent type
specified by
.IR parent-rtd ,
which should be an
expression evaluating to a record-type descriptor or \f[CR]#f\fP, and
.IR parent-rcd ,
which should be an expression evaluating to a
record-constructor descriptor or \f[CR]#f\fP.
See
.BR make-record-type-descriptor (3scm)
and
.BR make-record-constructor-descriptor (3scm).
.IP
If
.I parent-rtd
evaluates to \f[CR]#f\fP, then if
.I parent-rcd
evaluates to a value, that value must also be \f[CR]#f\fP.
.IP
If
.I parent-rtd
evaluates to a record-type descriptor, the record type must not be
sealed. Moreover, a record-type definition must not have both a
.B parent
and a
.B parent-rtd
clause.
.
If no
.B parent
clause is present, no
.B parent-rtd
clause is
present, or a
.B parent-rtd
clause is present but
.I parent-rtd
evaluates to \f[CR]#f\fP, the record type is a base type.
.\" r6rs-lib has a note about performance, but it is no longer accurate.
.
.TP
.B [R6RS] Record protocols
A record protocol can be specified with the
.BI "(protocol " expression )
clause.
The
.I expression
is evaluated in the same environment as the
.B define-record-type
form. It must evaluate to a procedure, and this procedure should be a
protocol appropriate for the record type being defined.
.IP
The protocol is used to create a record-constructor descriptor
as described above ("The constructor").
.
If no
.B protocol
clause is specified, a constructor descriptor is still created using a
default protocol. The clause can be absent only if the record type
being defined has no parent type, or if the
.B parent
definition does not specify a
.BR protocol .
.
.TP
.B [R6RS] Opaque record types
The record clause
.BI "(opaque " \f[CR]#t\fP )
defines the record type as opaque, which is also the
default if the parent record type is opaque. See
.BR record-rtd (3scm)
for details on what opaque means, but it essentially
makes it so that you can't inspect instances of the
record type.
.IP
The default, if the record type has no parent or the
parent type is not opaque, is that the record type is
not opaque. This can be made explicit with
.BI "(sealed " \f[CR]#f\fP )\fR.
.
.TP
.B [R6RS] Nongenerative record types
The record type can be made nongenerative
with
.BI "(nongenerative " uid )
or
.BI "(nongenerative)" \fP.
The
.I uid
must be an identifier.
If
.I uid
is absent, a unique uid is generated at macro-expansion time.
.IP
If two record-type definitions specify the same
.IR uid ,
then the record-type definitions
should be equivalent, i.e., the implied arguments to
.BR make-record-type-descriptor (3scm)
must be equivalent as described under
.BR make-record-type-descriptor (3scm).
If this condition is not met, it is either considered
a syntax violation or an exception with condition type
.BR &assertion (7scm)
is raised.
.IP
If the condition is met, a single record type is generated for both
definitions.
.IP
In the absence of a nongenerative clause, a new record type is
generated every time a
.B define-record-type
form is evaluated:
.IP
.EX
(let ((f (lambda (x)
               (define-record-type r ...)
               (if x r? (make-r ...)))))
   ((f #t) (f #f)))
     =>  #f
.EE
.
.TP
.B [R7RS] Record types are always generative
The
.B define-record-type
construct in R7RS is generative: each use creates a new record type
that is distinct from all existing types, including Scheme's
predefined types and other record types â€” even record types of the
same name or structure.
.
.
.TP
.B [R6RS] Implicit naming
Any definition that takes advantage of implicit naming for
the constructor, predicate, accessor, and mutator names
can be rewritten trivially to a definition that specifies all
names explicitly. For example, the implicit-naming record
definition:
.IP
.EX
(define-record-type frob
  (fields (mutable widget))
  (protocol
   (lambda (p)
     (lambda (n) (p (make-widget n))))))
.EE
.IP
is equivalent to the following explicit-naming record
definition.
.IP
.EX
(define-record-type (frob make-frob frob?)
  (fields (mutable widget
                   frob-widget
                   frob-widget-set!))
  (protocol
   (lambda (p)
     (lambda (n) (p (make-widget n))))))
.EE
.IP
Also, the implicit-naming record definition:
.IP
.EX
(define-record-type point (fields x y))
.EE
.IP
is equivalent to the following explicit-naming record
definition:
.IP
.EX
(define-record-type (point make-point point?)
  (fields
   (immutable x point-x)
   (immutable y point-y)))
.EE
.IP
With implicit naming, it is still possible to specify some of
the names explicitly; for example, the following overrides
the choice of accessor and mutator names for the widget
field.
.IP
.EX
(define-record-type frob
  (fields (mutable widget getwid setwid!))
  (protocol
   (lambda (p)
     (lambda (n) (p (make-widget n))))))
.EE
.
.TP
.B [R6RS] Retrieving the record-type descriptor
The expression
.BI "(record-type-descriptor " record-name )
evaluates to the record-type descriptor associated
with the type specified by
.IR record-name .
See
.BR make-record-type-descriptor (3scm).
.IP
The
.B record-type-descriptor
procedure works on both opaque and non-opaque record types.
.
.TP
.B [R6RS] Retrieving the record-constructor descriptor
The expression
.BI "(record-constructor-descriptor " record-name )
evaluates to the record-constructor descriptor
associated with
.IR record-name .
See
.BR make-record-constructor-descriptor (3scm).
.
.TP
.B Definition context
The
.B define-record-type
form is a definition and can appear anywhere any other definitions can
appear.
.
The
.B define-record-type
form expands into a set of definitions
in the environment where
.B define-record-type
appears; hence, it is possible to refer to the bindings (except for
that of the record type itself) recursively.
.
.TP
.B Distinct names
All bindings created by
.B define-record-type
(for the record type, the constructor, the predicate, the accessors,
and the mutators) must have names that are pairwise distinct.
.
.SH "IMPLEMENTATION NOTES"
.
Both the syntactic and procedural definitions of record can be
optimized using techniques from the paper
.I A Sufficiently Smart Compiler for Procedural Records
by Andy Keep and R. Kent Dybvig.
.
.SH "RETURN VALUES"
.
This syntax can not be used in a value context.
.
.SH EXAMPLES
.
.EX
;; This is an example from R7RS

; The following record-type definition
(define-record-type <pare>
   (kons x y)
   pare?
   (x kar set-kar!)
   (y kdr))
; defines kons to be a constructor, kar and kdr to be ac-
; cessors, set-kar! to be a modifier, and pare? to be a
; predicate for instances of <pare>.
(pare? (kons 1 2))            =>  #t
(pare? (cons 1 2))            =>  #f
(kar (kons 1 2))              =>  1
(kdr (kons 1 2))              =>  2
(let ((k (kons 1 2)))
  (set-kar! k 3)
  (kar k))                    =>  3


; This is an example from R6RS

(define-record-type (point make-point point?)
  (fields (immutable x point-x)
          (mutable y point-y set-point-y!))
  (nongenerative
    point-4893d957-e00b-11d9-817f-00111175eb9e))

(define-record-type (cpoint make-cpoint cpoint?)
  (parent point)
  (protocol
   (lambda (n)
     (lambda (x y c)
       ((n x y) (color->rgb c)))))
  (fields
    (mutable rgb cpoint-rgb cpoint-rgb-set!)))

(define (color->rgb c)
  (cons 'rgb c))

(define p1 (make-point 1 2))

(define p2 (make-cpoint 3 4 'red))

(point? p1)                   =>  #t
(point? p2)                   =>  #t
(point? (vector))             =>  #f
(point? (cons 'a 'b))         =>  #f
(cpoint? p1)                  =>  #f
(cpoint? p2)                  =>  #t
(point-x p1)                  =>  1
(point-y p1)                  =>  2
(point-x p2)                  =>  3
(point-y p2)                  =>  4
(cpoint-rgb p2)               =>  (rgb . red)
(set-point-y! p1 17)          =>  unspecified
(point-y p1)                  =>  17)
(record-rtd p1)
          =>  (record-type-descriptor point)

(define-record-type (ex1 make-ex1 ex1?)
  (protocol (lambda (p) (lambda a (p a))))
  (fields (immutable f ex1-f)))

(define ex1-i1 (make-ex1 1 2 3))

(ex1-f ex1-i1)               =>  (1 2 3)

(define-record-type (ex2 make-ex2 ex2?)
  (protocol
    (lambda (p) (lambda (a . b) (p a b))))
  (fields (immutable a ex2-a)
          (immutable b ex2-b)))

(define ex2-i1 (make-ex2 1 2 3))

(ex2-a ex2-i1)               =>  1
(ex2-b ex2-i1)               =>  (2 3)

(define-record-type (unit-vector
                     make-unit-vector
                     unit-vector?)
  (protocol
   (lambda (p)
     (lambda (x y z)
       (let ((length
               (sqrt (+ (* x x)
                         (* y y)
                         (* z z)))))
         (p (/ x length)
            (/ y length)
            (/ z length))))))
  (fields (immutable x unit-vector-x)
          (immutable y unit-vector-y)
          (immutable z unit-vector-z)))

(define *ex3-instance* #f)

(define-record-type ex3
  (parent cpoint)
  (protocol
   (lambda (n)
     (lambda (x y t)
       (let ((r ((n x y 'red) t)))
         (set! *ex3-instance* r)
         r))))
  (fields
   (mutable thickness))
  (sealed #t) (opaque #t))

(define ex3-i1 (make-ex3 1 2 17))

(ex3? ex3-i1)                =>  #t
(cpoint-rgb ex3-i1)          =>  (rgb . red)
(ex3-thickness ex3-i1)       =>  17
(ex3-thickness-set! ex3-i1 18)
          =>  unspecified
(ex3-thickness ex3-i1)       =>  18
*ex3-instance*               =>  ex3-i1
(record? ex3-i1) =>  #f
.EE
.
.SH "APPLICATION USAGE"
.
Record types are used extensively to create new data types. Older Lisp
and Scheme code often used pairs and vectors, but this resulted in
messy code that was hard to follow.
\" .
\" .SH RATIONALE
\" .
.SH COMPATIBILITY
.
The R7RS variant of
.B define-record-type
is based on SRFI-9.
.PP
The R6RS variant is unique to R6RS. Porting it to a Scheme with
only
.BR syntax-rules (7scm)
is not possible because that macro language can not create names
that were not present in the original source code.
.
.SH ERRORS
This syntax can raise exceptions with the following condition types:
.TP
.BR &syntax " (R6RS)"
There was a syntax violation.
.TP
R7RS
There are several situations in this manual page that are
described as errors.
Implementations may signal an error, extend a procedure's
domain of definition to include such arguments,
or fail catastrophically.
.
.SH "SEE ALSO"
.
.BR make-record-type-descriptor (3scm)
.
.SH STANDARDS
SRFI-9,
R6RS,
R7RS
.
\" .SH HISTORY
\" .
.
.SH AUTHORS
This page is part of the
.I scheme-manpages
project.
It includes materials from the RnRS documents.
More information can be found at
.UR https://github.com/schemedoc/manpages/
.UE .
\" .
\" .SH BUGS
\" .
